
Soft_start.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000038c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000032  0000438c  0000038c  00000440  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000002  00800040  000003be  00000472  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000008  00800042  00800042  00000474  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00000474  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000004a4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000188  00000000  00000000  000004e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002bce  00000000  00000000  00000668  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000adb  00000000  00000000  00003236  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000b94  00000000  00000000  00003d11  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000284  00000000  00000000  000048a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000982  00000000  00000000  00004b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000dbe  00000000  00000000  000054ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001e8  00000000  00000000  0000626c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0f c0       	rjmp	.+30     	; 0x20 <__ctors_end>
   2:	29 c0       	rjmp	.+82     	; 0x56 <__bad_interrupt>
   4:	28 c0       	rjmp	.+80     	; 0x56 <__bad_interrupt>
   6:	27 c0       	rjmp	.+78     	; 0x56 <__bad_interrupt>
   8:	26 c0       	rjmp	.+76     	; 0x56 <__bad_interrupt>
   a:	89 c1       	rjmp	.+786    	; 0x31e <__vector_5>
   c:	24 c0       	rjmp	.+72     	; 0x56 <__bad_interrupt>
   e:	23 c0       	rjmp	.+70     	; 0x56 <__bad_interrupt>
  10:	22 c0       	rjmp	.+68     	; 0x56 <__bad_interrupt>
  12:	21 c0       	rjmp	.+66     	; 0x56 <__bad_interrupt>
  14:	20 c0       	rjmp	.+64     	; 0x56 <__bad_interrupt>
  16:	1f c0       	rjmp	.+62     	; 0x56 <__bad_interrupt>
  18:	1e c0       	rjmp	.+60     	; 0x56 <__bad_interrupt>
  1a:	1d c0       	rjmp	.+58     	; 0x56 <__bad_interrupt>
  1c:	1c c0       	rjmp	.+56     	; 0x56 <__bad_interrupt>
  1e:	1b c0       	rjmp	.+54     	; 0x56 <__bad_interrupt>

00000020 <__ctors_end>:
  20:	11 27       	eor	r17, r17
  22:	1f bf       	out	0x3f, r17	; 63
  24:	cf e5       	ldi	r28, 0x5F	; 95
  26:	d0 e0       	ldi	r29, 0x00	; 0
  28:	de bf       	out	0x3e, r29	; 62
  2a:	cd bf       	out	0x3d, r28	; 61

0000002c <__do_copy_data>:
  2c:	20 e0       	ldi	r18, 0x00	; 0
  2e:	a0 e4       	ldi	r26, 0x40	; 64
  30:	b0 e0       	ldi	r27, 0x00	; 0
  32:	ee eb       	ldi	r30, 0xBE	; 190
  34:	f3 e4       	ldi	r31, 0x43	; 67
  36:	02 c0       	rjmp	.+4      	; 0x3c <__CCP__>
  38:	31 91       	ld	r19, Z+
  3a:	3d 93       	st	X+, r19
  3c:	a2 34       	cpi	r26, 0x42	; 66
  3e:	b2 07       	cpc	r27, r18
  40:	d9 f7       	brne	.-10     	; 0x38 <__do_copy_data+0xc>

00000042 <__do_clear_bss>:
  42:	20 e0       	ldi	r18, 0x00	; 0
  44:	a2 e4       	ldi	r26, 0x42	; 66
  46:	b0 e0       	ldi	r27, 0x00	; 0
  48:	01 c0       	rjmp	.+2      	; 0x4c <.do_clear_bss_start>

0000004a <.do_clear_bss_loop>:
  4a:	1d 93       	st	X+, r17

0000004c <.do_clear_bss_start>:
  4c:	aa 34       	cpi	r26, 0x4A	; 74
  4e:	b2 07       	cpc	r27, r18
  50:	e1 f7       	brne	.-8      	; 0x4a <.do_clear_bss_loop>
  52:	03 d0       	rcall	.+6      	; 0x5a <main>
  54:	99 c1       	rjmp	.+818    	; 0x388 <_exit>

00000056 <__bad_interrupt>:
  56:	d4 cf       	rjmp	.-88     	; 0x0 <__vectors>

00000058 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
  58:	0e c1       	rjmp	.+540    	; 0x276 <system_init>

0000005a <main>:
static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on);

int main(void)
{
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  5a:	fe df       	rcall	.-4      	; 0x58 <atmel_start_init>
	
	ENABLE_INTERRUPTS();
  5c:	78 94       	sei
	
	/*PWM timer is also used as a time base to get a tick every 0.5 s*/
	TIME_Init();
  5e:	8d d1       	rcall	.+794    	; 0x37a <TIME_Init>

	/* Replace with your application code */
	while (1) {
		if(TIME_IsOneSecondPassed()) {
  60:	8f d1       	rcall	.+798    	; 0x380 <TIME_IsOneSecondPassed>
  62:	88 23       	and	r24, r24
  64:	e9 f3       	breq	.-6      	; 0x60 <__stack+0x1>
			if(!is_motor_working) {
  66:	42 a1       	lds	r20, 0x42	; 0x800042 <__data_end>
  68:	41 13       	cpse	r20, r17
  6a:	44 c0       	rjmp	.+136    	; 0xf4 <__stack+0x95>
				current_level = MOTOR_GetLevel(ADC_0_get_conversion(ADC_TIME_CTRL_CH));
  6c:	83 e0       	ldi	r24, 0x03	; 3
  6e:	f4 d0       	rcall	.+488    	; 0x258 <ADC_0_get_conversion>
	}
}

static eLEVLES MOTOR_GetLevel(uint16_t time_ctrl_val) {
	/*0 is about 330, because there is potentiometer 10K and 4K7 resistor in series so 1024*(4K7/14K7) = ~330*/
	if(time_ctrl_val < 520) {
  70:	88 30       	cpi	r24, 0x08	; 8
  72:	42 e0       	ldi	r20, 0x02	; 2
  74:	94 07       	cpc	r25, r20
  76:	08 f4       	brcc	.+2      	; 0x7a <__stack+0x1b>
  78:	8d c0       	rjmp	.+282    	; 0x194 <__stack+0x135>
		return LEVEL_1;
	}
	else if(time_ctrl_val < 650) {
  7a:	8a 38       	cpi	r24, 0x8A	; 138
  7c:	42 e0       	ldi	r20, 0x02	; 2
  7e:	94 07       	cpc	r25, r20
  80:	08 f4       	brcc	.+2      	; 0x84 <__stack+0x25>
  82:	9d c0       	rjmp	.+314    	; 0x1be <__stack+0x15f>
		return LEVEL_2;
	}
	else if(time_ctrl_val < 760) {
  84:	88 3f       	cpi	r24, 0xF8	; 248
  86:	42 e0       	ldi	r20, 0x02	; 2
  88:	94 07       	cpc	r25, r20
  8a:	08 f4       	brcc	.+2      	; 0x8e <__stack+0x2f>
  8c:	d5 c0       	rjmp	.+426    	; 0x238 <__stack+0x1d9>
		return LEVEL_3;
	}
	else if(time_ctrl_val < 940) {
  8e:	8c 3a       	cpi	r24, 0xAC	; 172
  90:	93 40       	sbci	r25, 0x03	; 3
  92:	08 f4       	brcc	.+2      	; 0x96 <__stack+0x37>
  94:	d3 c0       	rjmp	.+422    	; 0x23c <__stack+0x1dd>
		return LEVEL_4;
	}
	else {
		return LEVEL_5;
  96:	44 e0       	ldi	r20, 0x04	; 4

	/* Replace with your application code */
	while (1) {
		if(TIME_IsOneSecondPassed()) {
			if(!is_motor_working) {
				current_level = MOTOR_GetLevel(ADC_0_get_conversion(ADC_TIME_CTRL_CH));
  98:	45 a9       	sts	0x45, r20	; 0x800045 <current_level>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
  9a:	50 a1       	lds	r21, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
  9c:	54 17       	cp	r21, r20
  9e:	91 f0       	breq	.+36     	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
  a0:	40 a9       	sts	0x40, r20	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
  a2:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
  a4:	14 9a       	sbi	0x02, 4	; 2
  a6:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
  a8:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
  aa:	15 9a       	sbi	0x02, 5	; 2
		LED_3_set_level(true);
		LED_4_set_level(true);
		LED_5_set_level(true);
	}
	
	switch(num_of_leds_to_turn_on) {
  ac:	42 30       	cpi	r20, 0x02	; 2
  ae:	09 f4       	brne	.+2      	; 0xb2 <__stack+0x53>
  b0:	bf c0       	rjmp	.+382    	; 0x230 <__stack+0x1d1>
  b2:	08 f0       	brcs	.+2      	; 0xb6 <__stack+0x57>
  b4:	86 c0       	rjmp	.+268    	; 0x1c2 <__stack+0x163>
  b6:	44 23       	and	r20, r20
  b8:	09 f4       	brne	.+2      	; 0xbc <__stack+0x5d>
  ba:	7f c0       	rjmp	.+254    	; 0x1ba <__stack+0x15b>
  bc:	41 30       	cpi	r20, 0x01	; 1
  be:	11 f4       	brne	.+4      	; 0xc4 <__stack+0x65>
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
  c0:	33 98       	cbi	0x06, 3	; 6
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
  c2:	14 98       	cbi	0x02, 4	; 2
			}
			else {
				motor_time_of_work_counter_s++;
				MOTOR_SoftStart();
			}
			if((ADC_0_get_conversion(ADC_LOAD_DET_CH) < 200) && !is_motor_working) {
  c4:	84 e0       	ldi	r24, 0x04	; 4
  c6:	c8 d0       	rcall	.+400    	; 0x258 <ADC_0_get_conversion>
  c8:	88 3c       	cpi	r24, 0xC8	; 200
  ca:	91 07       	cpc	r25, r17
  cc:	20 f4       	brcc	.+8      	; 0xd6 <__stack+0x77>
  ce:	42 a1       	lds	r20, 0x42	; 0x800042 <__data_end>
  d0:	44 23       	and	r20, r20
  d2:	09 f4       	brne	.+2      	; 0xd6 <__stack+0x77>
  d4:	61 c0       	rjmp	.+194    	; 0x198 <__stack+0x139>
				/*Start motor*/
				is_motor_working = true;
				PWM_0_enable_output_ch0();
			}
			if(motor_time_of_work_counter_s >= MOTOR_TIME_OF_WORK_S) {
  d6:	43 a1       	lds	r20, 0x43	; 0x800043 <motor_time_of_work_counter_s>
  d8:	54 a1       	lds	r21, 0x44	; 0x800044 <motor_time_of_work_counter_s+0x1>
  da:	42 33       	cpi	r20, 0x32	; 50
  dc:	51 07       	cpc	r21, r17
  de:	08 f4       	brcc	.+2      	; 0xe2 <__stack+0x83>
  e0:	bf cf       	rjmp	.-130    	; 0x60 <__stack+0x1>
				is_motor_working = false;
  e2:	12 a9       	sts	0x42, r17	; 0x800042 <__data_end>
				motor_time_of_work_counter_s = 0;
  e4:	14 a9       	sts	0x44, r17	; 0x800044 <motor_time_of_work_counter_s+0x1>
  e6:	13 a9       	sts	0x43, r17	; 0x800043 <motor_time_of_work_counter_s>
				PWM_0_load_duty_cycle_ch0(0x00); //Reset PWM
  e8:	80 e0       	ldi	r24, 0x00	; 0
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	12 d1       	rcall	.+548    	; 0x312 <PWM_0_load_duty_cycle_ch0>
				PWM_0_disable_output_ch0();
  ee:	0e d1       	rcall	.+540    	; 0x30c <PWM_0_disable_output_ch0>
  f0:	13 98       	cbi	0x02, 3	; 2
  f2:	b6 cf       	rjmp	.-148    	; 0x60 <__stack+0x1>
			if(!is_motor_working) {
				current_level = MOTOR_GetLevel(ADC_0_get_conversion(ADC_TIME_CTRL_CH));
				LED_SetIndication(current_level);
			}
			else {
				motor_time_of_work_counter_s++;
  f4:	63 a1       	lds	r22, 0x43	; 0x800043 <motor_time_of_work_counter_s>
  f6:	74 a1       	lds	r23, 0x44	; 0x800044 <motor_time_of_work_counter_s+0x1>
  f8:	6f 5f       	subi	r22, 0xFF	; 255
  fa:	7f 4f       	sbci	r23, 0xFF	; 255
  fc:	74 a9       	sts	0x44, r23	; 0x800044 <motor_time_of_work_counter_s+0x1>
  fe:	63 a9       	sts	0x43, r22	; 0x800043 <motor_time_of_work_counter_s>
}

static uint16_t	MOTOR_GetTimeForThreshold(uint8_t threshiold) {
	uint16_t time = 0;
	for(int i = 0; i < threshiold + 1; i++) {
		time += MOTOR_ThresholdsDuration_s[current_level][i];
 100:	45 a1       	lds	r20, 0x45	; 0x800045 <current_level>
 102:	50 e0       	ldi	r21, 0x00	; 0
 104:	e4 2f       	mov	r30, r20
 106:	f5 2f       	mov	r31, r21
 108:	ee 0f       	add	r30, r30
 10a:	ff 1f       	adc	r31, r31
 10c:	ee 0f       	add	r30, r30
 10e:	ff 1f       	adc	r31, r31
 110:	e4 0f       	add	r30, r20
 112:	f5 1f       	adc	r31, r21
 114:	ee 0f       	add	r30, r30
 116:	ff 1f       	adc	r31, r31
 118:	e4 57       	subi	r30, 0x74	; 116
 11a:	fc 4b       	sbci	r31, 0xBC	; 188
 11c:	81 91       	ld	r24, Z+
 11e:	90 81       	ld	r25, Z
 120:	e1 50       	subi	r30, 0x01	; 1
 122:	f0 40       	sbci	r31, 0x00	; 0
	}
	return time;
}

static void MOTOR_SoftStart(void) {
	if(motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(0)) {
 124:	68 17       	cp	r22, r24
 126:	79 07       	cpc	r23, r25
 128:	d8 f1       	brcs	.+118    	; 0x1a0 <__stack+0x141>
}

static uint16_t	MOTOR_GetTimeForThreshold(uint8_t threshiold) {
	uint16_t time = 0;
	for(int i = 0; i < threshiold + 1; i++) {
		time += MOTOR_ThresholdsDuration_s[current_level][i];
 12a:	ee 5f       	subi	r30, 0xFE	; 254
 12c:	ff 4f       	sbci	r31, 0xFF	; 255
 12e:	41 91       	ld	r20, Z+
 130:	50 81       	ld	r21, Z
 132:	e3 50       	subi	r30, 0x03	; 3
 134:	f0 40       	sbci	r31, 0x00	; 0
 136:	48 0f       	add	r20, r24
 138:	59 1f       	adc	r21, r25
static void MOTOR_SoftStart(void) {
	if(motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(0)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[0]);
		LED_SetIndication(0);
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(1)) {
 13a:	64 17       	cp	r22, r20
 13c:	75 07       	cpc	r23, r21
 13e:	08 f4       	brcc	.+2      	; 0x142 <__stack+0xe3>
 140:	4b c0       	rjmp	.+150    	; 0x1d8 <__stack+0x179>
}

static uint16_t	MOTOR_GetTimeForThreshold(uint8_t threshiold) {
	uint16_t time = 0;
	for(int i = 0; i < threshiold + 1; i++) {
		time += MOTOR_ThresholdsDuration_s[current_level][i];
 142:	ec 5f       	subi	r30, 0xFC	; 252
 144:	ff 4f       	sbci	r31, 0xFF	; 255
 146:	81 91       	ld	r24, Z+
 148:	90 81       	ld	r25, Z
 14a:	e5 50       	subi	r30, 0x05	; 5
 14c:	f0 40       	sbci	r31, 0x00	; 0
 14e:	48 0f       	add	r20, r24
 150:	59 1f       	adc	r21, r25
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(1)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[1]);
		LED_SetIndication(1);
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(2)) {
 152:	64 17       	cp	r22, r20
 154:	75 07       	cpc	r23, r21
 156:	08 f4       	brcc	.+2      	; 0x15a <__stack+0xfb>
 158:	5d c0       	rjmp	.+186    	; 0x214 <__stack+0x1b5>
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[2]);
		LED_SetIndication(2);
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(3)) {
 15a:	ea 5f       	subi	r30, 0xFA	; 250
 15c:	ff 4f       	sbci	r31, 0xFF	; 255
 15e:	81 91       	ld	r24, Z+
 160:	90 81       	ld	r25, Z
 162:	48 0f       	add	r20, r24
 164:	59 1f       	adc	r21, r25
 166:	64 17       	cp	r22, r20
 168:	75 07       	cpc	r23, r21
 16a:	08 f0       	brcs	.+2      	; 0x16e <__stack+0x10f>
 16c:	44 c0       	rjmp	.+136    	; 0x1f6 <__stack+0x197>
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[3]);
 16e:	83 e1       	ldi	r24, 0x13	; 19
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	cf d0       	rcall	.+414    	; 0x312 <PWM_0_load_duty_cycle_ch0>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
 174:	40 a1       	lds	r20, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
 176:	43 30       	cpi	r20, 0x03	; 3
 178:	09 f4       	brne	.+2      	; 0x17c <__stack+0x11d>
 17a:	a4 cf       	rjmp	.-184    	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
 17c:	43 e0       	ldi	r20, 0x03	; 3
 17e:	40 a9       	sts	0x40, r20	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 180:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 182:	14 9a       	sbi	0x02, 4	; 2
 184:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 186:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 188:	15 9a       	sbi	0x02, 5	; 2
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
 18a:	33 98       	cbi	0x06, 3	; 6
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
 18c:	14 98       	cbi	0x02, 4	; 2
 18e:	17 98       	cbi	0x02, 7	; 2
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
 190:	32 98       	cbi	0x06, 2	; 6
 192:	98 cf       	rjmp	.-208    	; 0xc4 <__stack+0x65>
}

static eLEVLES MOTOR_GetLevel(uint16_t time_ctrl_val) {
	/*0 is about 330, because there is potentiometer 10K and 4K7 resistor in series so 1024*(4K7/14K7) = ~330*/
	if(time_ctrl_val < 520) {
		return LEVEL_1;
 194:	40 e0       	ldi	r20, 0x00	; 0
 196:	80 cf       	rjmp	.-256    	; 0x98 <__stack+0x39>
				motor_time_of_work_counter_s++;
				MOTOR_SoftStart();
			}
			if((ADC_0_get_conversion(ADC_LOAD_DET_CH) < 200) && !is_motor_working) {
				/*Start motor*/
				is_motor_working = true;
 198:	41 e0       	ldi	r20, 0x01	; 1
 19a:	42 a9       	sts	0x42, r20	; 0x800042 <__data_end>
				PWM_0_enable_output_ch0();
 19c:	b3 d0       	rcall	.+358    	; 0x304 <PWM_0_enable_output_ch0>
 19e:	9b cf       	rjmp	.-202    	; 0xd6 <__stack+0x77>
	return time;
}

static void MOTOR_SoftStart(void) {
	if(motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(0)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[0]);
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	b6 d0       	rcall	.+364    	; 0x312 <PWM_0_load_duty_cycle_ch0>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
 1a6:	40 a1       	lds	r20, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
 1a8:	44 23       	and	r20, r20
 1aa:	09 f4       	brne	.+2      	; 0x1ae <__stack+0x14f>
 1ac:	8b cf       	rjmp	.-234    	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
 1ae:	10 a9       	sts	0x40, r17	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 1b0:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 1b2:	14 9a       	sbi	0x02, 4	; 2
 1b4:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 1b6:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 1b8:	15 9a       	sbi	0x02, 5	; 2
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
 1ba:	33 98       	cbi	0x06, 3	; 6
 1bc:	83 cf       	rjmp	.-250    	; 0xc4 <__stack+0x65>
	/*0 is about 330, because there is potentiometer 10K and 4K7 resistor in series so 1024*(4K7/14K7) = ~330*/
	if(time_ctrl_val < 520) {
		return LEVEL_1;
	}
	else if(time_ctrl_val < 650) {
		return LEVEL_2;
 1be:	41 e0       	ldi	r20, 0x01	; 1
 1c0:	6b cf       	rjmp	.-298    	; 0x98 <__stack+0x39>
		LED_3_set_level(true);
		LED_4_set_level(true);
		LED_5_set_level(true);
	}
	
	switch(num_of_leds_to_turn_on) {
 1c2:	43 30       	cpi	r20, 0x03	; 3
 1c4:	11 f3       	breq	.-60     	; 0x18a <__stack+0x12b>
 1c6:	44 30       	cpi	r20, 0x04	; 4
 1c8:	09 f0       	breq	.+2      	; 0x1cc <__stack+0x16d>
 1ca:	7c cf       	rjmp	.-264    	; 0xc4 <__stack+0x65>
 1cc:	33 98       	cbi	0x06, 3	; 6
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
 1ce:	14 98       	cbi	0x02, 4	; 2
 1d0:	17 98       	cbi	0x02, 7	; 2
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
 1d2:	32 98       	cbi	0x06, 2	; 6
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
 1d4:	15 98       	cbi	0x02, 5	; 2
 1d6:	76 cf       	rjmp	.-276    	; 0xc4 <__stack+0x65>
	if(motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(0)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[0]);
		LED_SetIndication(0);
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(1)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[1]);
 1d8:	85 e0       	ldi	r24, 0x05	; 5
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	9a d0       	rcall	.+308    	; 0x312 <PWM_0_load_duty_cycle_ch0>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
 1de:	40 a1       	lds	r20, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
 1e0:	41 30       	cpi	r20, 0x01	; 1
 1e2:	09 f4       	brne	.+2      	; 0x1e6 <__stack+0x187>
 1e4:	6f cf       	rjmp	.-290    	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
 1e6:	41 e0       	ldi	r20, 0x01	; 1
 1e8:	40 a9       	sts	0x40, r20	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 1ea:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 1ec:	14 9a       	sbi	0x02, 4	; 2
 1ee:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 1f0:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 1f2:	15 9a       	sbi	0x02, 5	; 2
 1f4:	65 cf       	rjmp	.-310    	; 0xc0 <__stack+0x61>
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(3)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[3]);
		LED_SetIndication(3);
	}
	else {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[4]);
 1f6:	80 e4       	ldi	r24, 0x40	; 64
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	8b d0       	rcall	.+278    	; 0x312 <PWM_0_load_duty_cycle_ch0>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
 1fc:	40 a1       	lds	r20, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
 1fe:	44 30       	cpi	r20, 0x04	; 4
 200:	09 f4       	brne	.+2      	; 0x204 <__stack+0x1a5>
 202:	60 cf       	rjmp	.-320    	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
 204:	44 e0       	ldi	r20, 0x04	; 4
 206:	40 a9       	sts	0x40, r20	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 208:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 20a:	14 9a       	sbi	0x02, 4	; 2
 20c:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 20e:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 210:	15 9a       	sbi	0x02, 5	; 2
 212:	dc cf       	rjmp	.-72     	; 0x1cc <__stack+0x16d>
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(1)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[1]);
		LED_SetIndication(1);
	}
	else if (motor_time_of_work_counter_s < MOTOR_GetTimeForThreshold(2)) {
		PWM_0_load_duty_cycle_ch0(MOTOR_PwmThresholds[2]);
 214:	89 e0       	ldi	r24, 0x09	; 9
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	7c d0       	rcall	.+248    	; 0x312 <PWM_0_load_duty_cycle_ch0>
}

static void LED_SetIndication(const uint8_t num_of_leds_to_turn_on) {
	static uint8_t turned_on_leds = 5; //set 5 at first to pass return condition after launch
	
	if(turned_on_leds == num_of_leds_to_turn_on) {
 21a:	40 a1       	lds	r20, 0x40	; 0x800040 <__DATA_REGION_ORIGIN__>
 21c:	42 30       	cpi	r20, 0x02	; 2
 21e:	09 f4       	brne	.+2      	; 0x222 <__stack+0x1c3>
 220:	51 cf       	rjmp	.-350    	; 0xc4 <__stack+0x65>
		return;
	}
	else {
		turned_on_leds = num_of_leds_to_turn_on;
 222:	42 e0       	ldi	r20, 0x02	; 2
 224:	40 a9       	sts	0x40, r20	; 0x800040 <__DATA_REGION_ORIGIN__>
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 226:	33 9a       	sbi	0x06, 3	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 228:	14 9a       	sbi	0x02, 4	; 2
 22a:	17 9a       	sbi	0x02, 7	; 2
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 22c:	32 9a       	sbi	0x06, 2	; 6
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 22e:	15 9a       	sbi	0x02, 5	; 2
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
	} else {
		PORTB &= ~(1 << pin);
 230:	33 98       	cbi	0x06, 3	; 6
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
 232:	14 98       	cbi	0x02, 4	; 2
 234:	17 98       	cbi	0x02, 7	; 2
 236:	46 cf       	rjmp	.-372    	; 0xc4 <__stack+0x65>
	}
	else if(time_ctrl_val < 650) {
		return LEVEL_2;
	}
	else if(time_ctrl_val < 760) {
		return LEVEL_3;
 238:	42 e0       	ldi	r20, 0x02	; 2
 23a:	2e cf       	rjmp	.-420    	; 0x98 <__stack+0x39>
	}
	else if(time_ctrl_val < 940) {
		return LEVEL_4;
 23c:	43 e0       	ldi	r20, 0x03	; 3
 23e:	2c cf       	rjmp	.-424    	; 0x98 <__stack+0x39>

00000240 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADCL | ADCH << 8);
}
 240:	45 b7       	in	r20, 0x35	; 53
 242:	4d 7f       	andi	r20, 0xFD	; 253
 244:	45 bf       	out	0x35, r20	; 53
 246:	43 e0       	ldi	r20, 0x03	; 3
 248:	4b bb       	out	0x1b, r20	; 27
 24a:	41 e8       	ldi	r20, 0x81	; 129
 24c:	4d bb       	out	0x1d, r20	; 29
 24e:	1c bb       	out	0x1c, r17	; 28
 250:	48 e1       	ldi	r20, 0x18	; 24
 252:	47 bb       	out	0x17, r20	; 23
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	08 95       	ret

00000258 <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_0_channel_t channel)
{
	ADMUX &= ~0x07;
 258:	4b b3       	in	r20, 0x1b	; 27
 25a:	48 7f       	andi	r20, 0xF8	; 248
 25c:	4b bb       	out	0x1b, r20	; 27
	ADMUX |= channel;
 25e:	4b b3       	in	r20, 0x1b	; 27
 260:	84 2b       	or	r24, r20
 262:	8b bb       	out	0x1b, r24	; 27
	ADCSRA |= (1 << ADSC);
 264:	ee 9a       	sbi	0x1d, 6	; 29
adc_result_t ADC_0_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
 266:	ec 9b       	sbis	0x1d, 4	; 29
 268:	fe cf       	rjmp	.-4      	; 0x266 <ADC_0_get_conversion+0xe>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADCL | ADCH << 8);
 26a:	89 b3       	in	r24, 0x19	; 25
 26c:	4a b3       	in	r20, 0x1a	; 26

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADCSRA |= (1 << ADIF);
 26e:	ec 9a       	sbi	0x1d, 4	; 29
	return res;
 270:	90 e0       	ldi	r25, 0x00	; 0
 272:	94 2b       	or	r25, r20
}
 274:	08 95       	ret

00000276 <system_init>:
{
	/* On AVR devices all peripherals are enabled from power on reset, this
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	PRR = (1 << PRTIM0) | (1 << PRADC) | (1 << PRUSART);
 276:	47 e0       	ldi	r20, 0x07	; 7
 278:	45 bf       	out	0x35, r20	; 53
		DDRA |= mask; /* Disable pull-up when configured as output */

		PUEA &= ~mask;
		break;
	case PORT_DIR_OFF:
		DDRA &= ~mask;
 27a:	41 b1       	in	r20, 0x01	; 1
 27c:	11 b9       	out	0x01, r17	; 1

		PUEA |= mask;
 27e:	43 b1       	in	r20, 0x03	; 3
 280:	4f ef       	ldi	r20, 0xFF	; 255
 282:	43 b9       	out	0x03, r20	; 3
		DDRB |= mask; /* Disable pull-up when configured as output */

		PUEB &= ~mask;
		break;
	case PORT_DIR_OFF:
		DDRB &= ~mask;
 284:	45 b1       	in	r20, 0x05	; 5
 286:	40 7f       	andi	r20, 0xF0	; 240
 288:	45 b9       	out	0x05, r20	; 5

		PUEB |= mask;
 28a:	47 b1       	in	r20, 0x07	; 7
 28c:	4f 60       	ori	r20, 0x0F	; 15
 28e:	47 b9       	out	0x07, r20	; 7
	switch (direction) {
	case PORT_DIR_IN:
		DDRA &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRA |= 1 << pin; /* Disable pull-up when configured as output */
 290:	0b 9a       	sbi	0x01, 3	; 1

		PUEA &= ~(1 << pin);
 292:	1b 98       	cbi	0x03, 3	; 3
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
	} else {
		PORTA &= ~(1 << pin);
 294:	13 98       	cbi	0x02, 3	; 2
	switch (direction) {
	case PORT_DIR_IN:
		DDRA &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRA |= 1 << pin; /* Disable pull-up when configured as output */
 296:	0c 9a       	sbi	0x01, 4	; 1

		PUEA &= ~(1 << pin);
 298:	1c 98       	cbi	0x03, 4	; 3
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 29a:	14 9a       	sbi	0x02, 4	; 2
		DDRA &= ~(1 << pin);

		PUEA |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEA &= ~(1 << pin);
 29c:	1c 98       	cbi	0x03, 4	; 3
	switch (direction) {
	case PORT_DIR_IN:
		DDRA &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRA |= 1 << pin; /* Disable pull-up when configured as output */
 29e:	0d 9a       	sbi	0x01, 5	; 1

		PUEA &= ~(1 << pin);
 2a0:	1d 98       	cbi	0x03, 5	; 3
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 2a2:	15 9a       	sbi	0x02, 5	; 2
		DDRA &= ~(1 << pin);

		PUEA |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEA &= ~(1 << pin);
 2a4:	1d 98       	cbi	0x03, 5	; 3
	switch (direction) {
	case PORT_DIR_IN:
		DDRA &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRA |= 1 << pin; /* Disable pull-up when configured as output */
 2a6:	0f 9a       	sbi	0x01, 7	; 1

		PUEA &= ~(1 << pin);
 2a8:	1f 98       	cbi	0x03, 7	; 3
 *                  false = Pin level set to "low" state
 */
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTA |= 1 << pin;
 2aa:	17 9a       	sbi	0x02, 7	; 2
		DDRA &= ~(1 << pin);

		PUEA |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEA &= ~(1 << pin);
 2ac:	1f 98       	cbi	0x03, 7	; 3
	switch (direction) {
	case PORT_DIR_IN:
		DDRB &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRB |= 1 << pin; /* Disable pull-up when configured as output */
 2ae:	2a 9a       	sbi	0x05, 2	; 5

		PUEB &= ~(1 << pin);
 2b0:	3a 98       	cbi	0x07, 2	; 7
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 2b2:	32 9a       	sbi	0x06, 2	; 6
		DDRB &= ~(1 << pin);

		PUEB |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEB &= ~(1 << pin);
 2b4:	3a 98       	cbi	0x07, 2	; 7
	switch (direction) {
	case PORT_DIR_IN:
		DDRB &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		DDRB |= 1 << pin; /* Disable pull-up when configured as output */
 2b6:	2b 9a       	sbi	0x05, 3	; 5

		PUEB &= ~(1 << pin);
 2b8:	3b 98       	cbi	0x07, 3	; 7
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level) {
		PORTB |= 1 << pin;
 2ba:	33 9a       	sbi	0x06, 3	; 6
		DDRB &= ~(1 << pin);

		PUEB |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEB &= ~(1 << pin);
 2bc:	3b 98       	cbi	0x07, 3	; 7
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
 2be:	40 e0       	ldi	r20, 0x00	; 0
 2c0:	68 ed       	ldi	r22, 0xD8	; 216
 2c2:	86 e3       	ldi	r24, 0x36	; 54
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	05 d0       	rcall	.+10     	; 0x2d2 <protected_write_io>
static inline int8_t sysctrl_init()
{
	/* Set up system clock prescaler according to configuration */
	ccp_write_io((void *)&CLKPSR, (0 << CLKPS3) | (0 << CLKPS2) | (0 << CLKPS1) | (0 << CLKPS0));

	SMCR = (0 << SM2) | (0 << SM1) | (0 << SM0) | // Idle
 2c8:	1a bf       	out	0x3a, r17	; 58
		DDRA &= ~(1 << pin);

		PUEA |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEA &= ~(1 << pin);
 2ca:	1e 98       	cbi	0x03, 6	; 3
		DDRB &= ~(1 << pin);

		PUEB |= 1 << pin;
	} else if (pull_mode == PORT_PULL_OFF) {

		PUEB &= ~(1 << pin);
 2cc:	38 98       	cbi	0x07, 0	; 7
	TIME_CNTRL_set_pull_mode(PORT_PULL_OFF);

	// Disable pull-up.
	LOAD_DET_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
 2ce:	b8 df       	rcall	.-144    	; 0x240 <ADC_0_init>
}

void PWM_0_initialization(void)
{

	PWM_0_init();
 2d0:	05 c0       	rjmp	.+10     	; 0x2dc <PWM_0_init>

000002d2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	mov     r30, r24
 2d2:	e8 2f       	mov	r30, r24
	mov     r31, r25                // Load addr into Z
 2d4:	f9 2f       	mov	r31, r25
	out     CCP, r22                // Start CCP handshake
 2d6:	6c bf       	out	0x3c, r22	; 60
	st      Z, r20                  // Write value to I/O register
 2d8:	40 83       	st	Z, r20
	ret                             // Return to caller
 2da:	08 95       	ret

000002dc <PWM_0_init>:
 *
 * \return Nothing
 */
void PWM_0_load_duty_cycle_ch1(PWM_0_register_t duty_value)
{
	OCR0B = duty_value;
 2dc:	45 b7       	in	r20, 0x35	; 53
 2de:	4e 7f       	andi	r20, 0xFE	; 254
 2e0:	45 bf       	out	0x35, r20	; 53
 2e2:	42 e0       	ldi	r20, 0x02	; 2
 2e4:	4e bd       	out	0x2e, r20	; 46
 2e6:	4d e1       	ldi	r20, 0x1D	; 29
 2e8:	4d bd       	out	0x2d, r20	; 45
 2ea:	40 e5       	ldi	r20, 0x50	; 80
 2ec:	50 e0       	ldi	r21, 0x00	; 0
 2ee:	53 bd       	out	0x23, r21	; 35
 2f0:	42 bd       	out	0x22, r20	; 34
 2f2:	17 bd       	out	0x27, r17	; 39
 2f4:	16 bd       	out	0x26, r17	; 38
 2f6:	41 e0       	ldi	r20, 0x01	; 1
 2f8:	4b bd       	out	0x2b, r20	; 43
 2fa:	4f b5       	in	r20, 0x2f	; 47
 2fc:	42 60       	ori	r20, 0x02	; 2
 2fe:	4f bd       	out	0x2f, r20	; 47
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	08 95       	ret

00000304 <PWM_0_enable_output_ch0>:
 304:	4e b5       	in	r20, 0x2e	; 46
 306:	40 68       	ori	r20, 0x80	; 128
 308:	4e bd       	out	0x2e, r20	; 46
 30a:	08 95       	ret

0000030c <PWM_0_disable_output_ch0>:
 30c:	4e b5       	in	r20, 0x2e	; 46
 30e:	4e bd       	out	0x2e, r20	; 46
 310:	08 95       	ret

00000312 <PWM_0_load_duty_cycle_ch0>:
 312:	97 bd       	out	0x27, r25	; 39
 314:	86 bd       	out	0x26, r24	; 38
 316:	08 95       	ret

00000318 <PWM_0_register_callback>:
 *
 * \return Nothing.
 */
void PWM_0_register_callback(pwm_irq_cb_t f)
{
	PWM_0_cb = f;
 318:	98 a9       	sts	0x48, r25	; 0x800048 <PWM_0_cb+0x1>
 31a:	87 a9       	sts	0x47, r24	; 0x800047 <PWM_0_cb>
 31c:	08 95       	ret

0000031e <__vector_5>:
}

ISR(TIM0_OVF_vect)
{
 31e:	1f 93       	push	r17
 320:	0f 93       	push	r16
 322:	0f b7       	in	r16, 0x3f	; 63
 324:	0f 93       	push	r16
 326:	10 e0       	ldi	r17, 0x00	; 0
 328:	4f 93       	push	r20
 32a:	5f 93       	push	r21
 32c:	6f 93       	push	r22
 32e:	7f 93       	push	r23
 330:	8f 93       	push	r24
 332:	9f 93       	push	r25
 334:	af 93       	push	r26
 336:	bf 93       	push	r27
 338:	ef 93       	push	r30
 33a:	ff 93       	push	r31
	static volatile uint8_t callback_count = 0;

	// Clear the interrupt flag
	TIFR0 = TOV0;
 33c:	1a bd       	out	0x2a, r17	; 42

	/* callback function - interrupt every ~100Hz (10ms); 10ms * PWM_0_INTERRUPT_CB_RATE(100) = 1s */
	if ((++callback_count >= PWM_0_INTERRUPT_CB_RATE) && (PWM_0_INTERRUPT_CB_RATE != 0)) {
 33e:	46 a1       	lds	r20, 0x46	; 0x800046 <callback_count.1836>
 340:	4f 5f       	subi	r20, 0xFF	; 255
 342:	46 a9       	sts	0x46, r20	; 0x800046 <callback_count.1836>
 344:	44 36       	cpi	r20, 0x64	; 100
 346:	38 f0       	brcs	.+14     	; 0x356 <__vector_5+0x38>
		if (PWM_0_cb != NULL) {
 348:	e7 a1       	lds	r30, 0x47	; 0x800047 <PWM_0_cb>
 34a:	f8 a1       	lds	r31, 0x48	; 0x800048 <PWM_0_cb+0x1>
 34c:	e1 17       	cp	r30, r17
 34e:	f1 07       	cpc	r31, r17
 350:	09 f0       	breq	.+2      	; 0x354 <__vector_5+0x36>
			PWM_0_cb();
 352:	09 95       	icall
		}
		callback_count = 0;
 354:	16 a9       	sts	0x46, r17	; 0x800046 <callback_count.1836>
	}
}
 356:	ff 91       	pop	r31
 358:	ef 91       	pop	r30
 35a:	bf 91       	pop	r27
 35c:	af 91       	pop	r26
 35e:	9f 91       	pop	r25
 360:	8f 91       	pop	r24
 362:	7f 91       	pop	r23
 364:	6f 91       	pop	r22
 366:	5f 91       	pop	r21
 368:	4f 91       	pop	r20
 36a:	0f 91       	pop	r16
 36c:	0f bf       	out	0x3f, r16	; 63
 36e:	0f 91       	pop	r16
 370:	1f 91       	pop	r17
 372:	18 95       	reti

00000374 <TIME_Callback>:
#include "pwm_basic.h"

static volatile bool one_second = false;

static void TIME_Callback(void) {
	one_second = true;
 374:	41 e0       	ldi	r20, 0x01	; 1
 376:	49 a9       	sts	0x49, r20	; 0x800049 <one_second>
 378:	08 95       	ret

0000037a <TIME_Init>:
}

void TIME_Init(void) {
	PWM_0_register_callback((pwm_irq_cb_t)TIME_Callback);
 37a:	8a eb       	ldi	r24, 0xBA	; 186
 37c:	91 e0       	ldi	r25, 0x01	; 1
 37e:	cc cf       	rjmp	.-104    	; 0x318 <PWM_0_register_callback>

00000380 <TIME_IsOneSecondPassed>:
}

bool TIME_IsOneSecondPassed(void) {
	if(one_second) {
 380:	89 a1       	lds	r24, 0x49	; 0x800049 <one_second>
 382:	81 13       	cpse	r24, r17
		one_second = false;
 384:	19 a9       	sts	0x49, r17	; 0x800049 <one_second>
		return true;
	}
	else {
		return false;
	}
}
 386:	08 95       	ret

00000388 <_exit>:
 388:	f8 94       	cli

0000038a <__stop_program>:
 38a:	ff cf       	rjmp	.-2      	; 0x38a <__stop_program>
